// Exemplo de schema Prisma para PostgreSQL
// Objetivo: facilitar migração de SQLite -> Postgres
// Observação: este arquivo NÃO é usado pela aplicação por padrão.
// Para migrar, ajuste seu prisma/schema.prisma para provider = "postgresql"
// e aponte para DATABASE_URL com credenciais do Postgres.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // Ex.: postgres://user:pass@host:port/dbname?sslmode=require
}

// Modelos baseados no schema atual (mantendo tipos próximos para facilitar migração)
// Caso deseje precisão financeira, considere usar Decimal em vez de Float.

model User {
  id                String   @id @default(uuid())
  name              String
  email             String   @unique
  password          String
  role              Role
  createdAt         DateTime @default(now()) @db.Timestamp(6)
  updatedAt         DateTime @updatedAt @db.Timestamp(6)

  @@map("users")
}

enum Role {
  ADMIN
  STAFF
  CUSTOMER
}

model Category {
  id        String   @id @default(uuid())
  name      String   @unique
  imageUrl  String?
  products  Product[]
  createdAt DateTime @default(now()) @db.Timestamp(6)
  updatedAt DateTime @updatedAt @db.Timestamp(6)

  @@map("categories")
}

model Product {
  id          String    @id @default(uuid())
  name        String
  description String?
  price       Float     // considere Decimal para produção: Decimal @db.Decimal(10, 2)
  imageUrl    String?
  category    Category? @relation(fields: [categoryId], references: [id])
  categoryId  String?
  createdAt   DateTime  @default(now()) @db.Timestamp(6)
  updatedAt   DateTime  @updatedAt @db.Timestamp(6)

  @@map("products")
}

model Table {
  id        String   @id @default(uuid())
  number    Int      @unique
  seats     Int
  createdAt DateTime @default(now()) @db.Timestamp(6)
  updatedAt DateTime @updatedAt @db.Timestamp(6)
  orders    Order[]

  @@map("tables")
}

model Order {
  id          String      @id @default(uuid())
  table       Table?      @relation(fields: [tableId], references: [id])
  tableId     String?
  customer    User?       @relation(fields: [customerId], references: [id])
  customerId  String?
  status      OrderStatus @default(PENDING)
  total       Float       // considere Decimal para produção: Decimal @db.Decimal(10, 2)
  createdAt   DateTime    @default(now()) @db.Timestamp(6)
  updatedAt   DateTime    @updatedAt @db.Timestamp(6)
  items       OrderItem[]

  @@map("orders")
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PREPARING
  READY
  SERVED
  CANCELLED
}

model OrderItem {
  id        String   @id @default(uuid())
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   String
  product   Product  @relation(fields: [productId], references: [id])
  productId String
  quantity  Int      @default(1)
  price     Float    // considere Decimal para produção
  createdAt DateTime @default(now()) @db.Timestamp(6)
  updatedAt DateTime @updatedAt @db.Timestamp(6)

  @@map("order_items")
}

model RefreshToken {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now()) @db.Timestamp(6)

  @@map("refresh_tokens")
}